/*------------------------------------------------------------------------------
-- FILE:        creep.cpp
--
-- DATE:        March 11, 2013
--
-- MAINTAINERS: Callum Styan, Chris Porter, Nick Raposo, Kevin Tangeman, Steve Lo
--
-- FUNCTIONS:   Creep
--              getTargetDirection
--              Update
--              Move   
--              serializeCreep         
--
-- DESCRIPTION: Base functions for creeps. Movement, updating and target
--                direction.
------------------------------------------------------------------------------*/
#include "unit.h"
#include "creep.h"
#include <iostream>
#include <string>
#include <vector>
#include <math.h>

using namespace std;

//old constructor
Creep::Creep(int uid, Point pos, int hp, int atkdmg, int atkrng,
         int atkspd, int percep, int atkcnt, int spd, Direction direct,
         Point* path, int movespeed): MobileUnit(uid, pos, hp, atkdmg, atkrng, atkspd,
         percep, atkcnt, spd, direct), pPath(path), pSaved(NULL)
{
    //validation
    //psaved is initialized to NULL so that the game doesn't crash!
}

/*------------------------------------------------------------------------------
-- FUNCTION:    Creep - constructor
--
-- DATE:        March 26, 2013
--
-- DESIGNER:    Callum Styan
-- PROGRAMMER:  Callum Styan, Kevin Tangeman, Steve Lo
--
-- INTERFACE:   Creep(int uid, int side, Point pos, Point* path, int hp = 100,
--                  int atkdmg = 10, int atkrng = 10,
--                  int atkspd = 10, int percep = 10, int atkcnt = 30,
--                  int movespeed = 10, Direct direct = Direction())
--
--                uid: unit id generated by the server
--                pos: starting position when you call the ctor
--                path: pointer to all the points for the creeps pathing
--
-- RETURNS:     a new Creep object
--
-- DESCRIPTION: Creates a new Creep object.  Default values are given.
--              
--              The unit id must be specified, it is generated server side.
--              
--              The starting position must be specified, this should be the first value
--              of the path it is in.
--              
--              The *path must be specified, this stores the points for the lane that the
--              creep will move through.
------------------------------------------------------------------------------*/
Creep::Creep(int uid, int side, Point pos, Point* path, int hp, int atkdmg, int atkrng,
             int atkspd, int percep, int atkcnt, int movespeed, Direction direct):
             MobileUnit(uid, side, pos, hp, atkdmg, atkrng, atkspd, percep, atkcnt, movespeed, direct),
             pPath(path), pSaved(NULL)
{
    //any required validation
}

/*------------------------------------------------------------------------------
-- FUNCTION:    getTargetDirection
--
-- DATE:        2013/04/05
--
-- DESIGNER:    Chris Porter
-- PROGRAMMER:  Chris Porter
--
-- INTERFACE:   int getTargetDirection(int p1, int p2)
--
--				p1: The first value to compare
-- 				p2: The second value to compare
--
-- RETURNS:     int 
--				-1 	: left or above
--				0 	: same level
--				1	: right or below
--
-- DESCRIPTION: getTargetDirection is designed to take two values ( x or y )
--				and then tell the difference between them.
--				Then it will return the direction from the first point to the 
--				second in terms of screen coordinates.
--				IE:
--					getTargetDirection( 0, 10 ) will return 1.
--
--				This means we need to either move right or down. 
--				Incremementing the x or the y.
------------------------------------------------------------------------------*/
int Creep::getTargetDirection(int p1, int p2) {
    if(p1 < p2) /*Target is below or right. */
        return 1;
    else if (p1 > p2)  /* Target is above or left. */
        return -1;
    else /* Target on the same level. */
        return 0;
}
    

/*------------------------------------------------------------------------------
-- FUNCTION:    Update
--
-- DATE:        2013/04/05
--
-- DESIGNER:    Chris Porter
-- PROGRAMMER:  Chris Porter
--
-- INTERFACE:   void Update( Team& team )
--
-- RETURNS:     void 
--
-- DESCRIPTION: Logical steps for updating the creep. Overrides Unit::Update
-- 				to add in movement. 
------------------------------------------------------------------------------*/
void Creep::Update(Team& team)
{
    //if we are within half our our speed tot he piuint
    /* Check if we are at the next path point.  */
    if(pPath->x == position.x && pPath->y == position.y) {
        nextPoint();
    }
    
    /*If we have a Target check their stats. */
    if(pTarget != NULL) 
        CheckTarget();
    
    /* Search for Target. */

    if(pTarget == NULL)
        FindTarget(&team);

    if(pTarget != NULL && pSaved == NULL)
        pSaved = &position;
    
    /* If we found a new Target. */
    if(pTarget != NULL){
        if(inRange(position, pTarget->getPos(), attackRange))
        {
            Attack();
        }
        else 
        {
            Move(pTarget->getPos());
        }
    }
    else
    { /*No target. Move along path. */
        if(pSaved == 0)
        {
            Move(*pPath);
        }
        else
        {
            Move(*pSaved);
            if(position.x == pSaved->x && position.y == pSaved->y)
                pSaved = NULL;
        }
    }
}

/*------------------------------------------------------------------------------
-- FUNCTION:    Move
--
-- DATE:        2013/04/05
--
-- DESIGNER:    Nick Raposo, Cody Rossiter, Chris Porter
-- PROGRAMMER:  Nick Raposo, Cody Rossiter
--
-- INTERFACE:   void Move( Point pt )
--				
--				pt - A point to move towards.
--
-- RETURNS:     void 
--
-- DESCRIPTION: Moves the Creep in the direction of the two different points.
--				It calls GetTargetDirection to get the direction it needs to 
--				travel. (-1 = left, 0 = nowhere, 1 = right), then we times
--				this by the speed of the creep to move in the correct direction.
--
-- NOTES:       Fixed so it actually works now... Added a range check to the point
--              so that if you are within the move distance of the paths point
--              you will move directly to the point instead of getting stuck forever
--              within one pixel of the paths point.
------------------------------------------------------------------------------*/
void Creep::Move( Point pt ) {
    if((pPath->x - moveSpeed < position.x && pPath->x + moveSpeed > position.x) 
        && (pPath->y - moveSpeed < position.y && pPath->y + moveSpeed > position.y)) 
    {
        position.x = pPath->x;
        position.y = pPath->y;
    }
    else
    {
        position.x += getTargetDirection(position.x, pt.x) * moveSpeed;
        position.y += getTargetDirection(position.y, pt.y) * moveSpeed;
    }
}

/*------------------------------------------------------------------------------
-- FUNCTION:    nextPoint
--
-- DATE:        2013/04/09
--
-- DESIGNER:    Nick Raposo, Callum Styan
-- PROGRAMMER:  Nick Raposo
--
-- INTERFACE:   void nextPoint(void)
--
-- RETURNS:     void 
--
-- DESCRIPTION: If we are not at the end of the path we set the next point
--              to go to.  Needed to be updated so that
------------------------------------------------------------------------------*/
void Creep::nextPoint( void )
{
        ++pPath;
        if(pPath->x == -1 && pPath->y == -1)
        {
            --pPath;
        }
}

/*------------------------------------------------------------------------------
-- FUNCTION:    serializeCreep
--
-- DATE:        2013/03/11
--
-- DESIGNER:    Behnam Bastami, Aaron Lee, David Czech
-- PROGRAMMER:  Behnam Bastami
--
-- INTERFACE:   Unit::serializeCreep()
--
-- RETURNS:     string, the serialized Unit
--
-- DESCRIPTION: Converts the Creep classes members into one string to be sent over
-- the network between client and server.  Uses the mobile unit serialize function.
------------------------------------------------------------------------------*/
string Creep::serializeCreep()
{
    string s = MobileUnit::serializeMobileUnit();
    return s;
}

